# Generated by Django 5.2.5 on 2025-08-15 09:06
from django.db import migrations, models


# ---------- Helpers portables (SQLite / MySQL / PostgreSQL) ----------

def column_exists(schema_editor, table_name, column_name):
    vendor = schema_editor.connection.vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == "sqlite":
            cursor.execute(f"PRAGMA table_info('{table_name}')")
            return any(row[1] == column_name for row in cursor.fetchall())
        elif vendor == "mysql":
            cursor.execute("""
                SELECT 1
                FROM information_schema.COLUMNS
                WHERE TABLE_SCHEMA = DATABASE()
                  AND TABLE_NAME = %s
                  AND COLUMN_NAME = %s
                LIMIT 1
            """, [table_name, column_name])
            return cursor.fetchone() is not None
        elif vendor == "postgresql":
            cursor.execute("""
                SELECT 1
                  FROM information_schema.columns
                 WHERE table_name = %s AND column_name = %s
                LIMIT 1
            """, [table_name, column_name])
            return cursor.fetchone() is not None
        return False


def add_bool_column_if_missing(schema_editor, table, col):
    if column_exists(schema_editor, table, col):
        return
    vendor = schema_editor.connection.vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == "sqlite":
            cursor.execute(f'ALTER TABLE "{table}" ADD COLUMN "{col}" INTEGER NOT NULL DEFAULT 0')
        elif vendor == "mysql":
            cursor.execute(f'ALTER TABLE `{table}` ADD COLUMN `{col}` TINYINT(1) NOT NULL DEFAULT 0')
        elif vendor == "postgresql":
            cursor.execute(f'ALTER TABLE "{table}" ADD COLUMN "{col}" boolean NOT NULL DEFAULT false')
        else:
            # Otros motores: no hacemos nada
            pass


def index_exists(schema_editor, table_name, index_name):
    vendor = schema_editor.connection.vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == "sqlite":
            cursor.execute(f"PRAGMA index_list('{table_name}')")
            names = [row[1] for row in cursor.fetchall()]
            return index_name in names
        elif vendor == "mysql":
            cursor.execute("""
                SELECT 1
                FROM information_schema.STATISTICS
                WHERE TABLE_SCHEMA = DATABASE()
                  AND TABLE_NAME = %s
                  AND INDEX_NAME = %s
                LIMIT 1
            """, [table_name, index_name])
            return cursor.fetchone() is not None
        elif vendor == "postgresql":
            # Busca por nombre en esquemas visibles
            cursor.execute("""
                SELECT 1
                  FROM pg_indexes
                 WHERE indexname = %s
                LIMIT 1
            """, [index_name])
            return cursor.fetchone() is not None
        return False


def create_index_if_missing(schema_editor, table, index_name, columns):
    if index_exists(schema_editor, table, index_name):
        return
    vendor = schema_editor.connection.vendor
    if vendor == "mysql":
        qtbl = f"`{table}`"
        qidx = f"`{index_name}`"
        qcols = ", ".join(f"`{c}`" for c in columns)
    else:
        # sqlite y postgresql usan comillas dobles
        qtbl = f'"{table}"'
        qidx = f'"{index_name}"'
        qcols = ", ".join(f'"{c}"' for c in columns)
    sql = f"CREATE INDEX {qidx} ON {qtbl} ({qcols})"
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(sql)


def safe_drop_uniq_espacio_idx(apps, schema_editor):
    idx_name = "uniq_espacio_por_plan_y_anio_cuatri_nombre"
    table = "academia_core_espaciocurricular"
    vendor = schema_editor.connection.vendor
    with schema_editor.connection.cursor() as cursor:
        if vendor == "mysql":
            cursor.execute(f"SHOW INDEX FROM `{table}` WHERE Key_name=%s", [idx_name])
            if cursor.fetchall():
                cursor.execute(f"DROP INDEX `{idx_name}` ON `{table}`")
        elif vendor == "sqlite":
            cursor.execute(f"PRAGMA index_list('{table}')")
            names = [row[1] for row in cursor.fetchall()]
            if idx_name in names:
                cursor.execute(f'DROP INDEX "{idx_name}"')
        elif vendor == "postgresql":
            cursor.execute(
                "SELECT 1 FROM pg_indexes WHERE tablename=%s AND indexname=%s",
                [table, idx_name],
            )
            if cursor.fetchone():
                cursor.execute(f'DROP INDEX IF EXISTS "{idx_name}"')
        else:
            # Otros motores: no hacer nada
            pass


def noop(apps, schema_editor):
    pass


# --------- Adaptadores para RunPython (funciones con firma (apps, se)) ---------

def op_add_bool(table, col):
    def _inner(apps, schema_editor):
        add_bool_column_if_missing(schema_editor, table, col)
    return _inner


def op_create_index(table, index_name, columns):
    def _inner(apps, schema_editor):
        create_index_if_missing(schema_editor, table, index_name, columns)
    return _inner


# ---------------------------- Migración ----------------------------

class Migration(migrations.Migration):

    dependencies = [
        ('academia_core', '0017_remove_espaciocurricular_uniq_espacio_por_plan_y_anio_cuatri_nombre_and_more'),
    ]

    operations = [
        # 1) DROP INDEX condicional, multi-motor
        migrations.RunPython(safe_drop_uniq_espacio_idx, reverse_code=noop),

        # 2) Actualiza el estado de Django quitando el constraint del ProjectState
        migrations.RunSQL(
            sql=migrations.RunSQL.noop,
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.RemoveConstraint(
                    model_name='espaciocurricular',
                    name='uniq_espacio_por_plan_y_anio_cuatri_nombre',
                ),
            ],
        ),

        # 3) ADD COLUMN condicionales, multi-motor (y estado de Django)
        migrations.RunPython(
            code=op_add_bool("academia_core_movimiento", "ausencia_justificada"),
            reverse_code=noop,
        ),
        migrations.RunSQL(
            sql=migrations.RunSQL.noop,
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.AddField(
                    model_name='movimiento',
                    name='ausencia_justificada',
                    field=models.BooleanField(default=False),
                ),
            ],
        ),

        migrations.RunPython(
            code=op_add_bool("academia_core_movimiento", "ausente"),
            reverse_code=noop,
        ),
        migrations.RunSQL(
            sql=migrations.RunSQL.noop,
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.AddField(
                    model_name='movimiento',
                    name='ausente',
                    field=models.BooleanField(default=False),
                ),
            ],
        ),

        # 4) Índices no-únicos condicionales (y estado de Django)
        migrations.RunPython(
            code=op_create_index(
                table="academia_core_espaciocurricular",
                index_name="academia_co_profeso_0214a3_idx",
                columns=["profesorado_id", "plan_id", "nombre"],
            ),
            reverse_code=noop,
        ),
        migrations.RunSQL(
            sql=migrations.RunSQL.noop,
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.AddIndex(
                    model_name='espaciocurricular',
                    index=models.Index(
                        fields=['profesorado', 'plan', 'nombre'],
                        name='academia_co_profeso_0214a3_idx',
                    ),
                ),
            ],
        ),

        migrations.RunPython(
            code=op_create_index(
                table="academia_core_inscripcionespacio",
                index_name="idx_cursada_insc_anio",
                columns=["inscripcion_id", "anio_academico"],
            ),
            reverse_code=noop,
        ),
        migrations.RunSQL(
            sql=migrations.RunSQL.noop,
            reverse_sql=migrations.RunSQL.noop,
            state_operations=[
                migrations.AddIndex(
                    model_name='inscripcionespacio',
                    index=models.Index(
                        fields=['inscripcion', 'anio_academico'],
                        name='idx_cursada_insc_anio',
                    ),
                ),
            ],
        ),
    ]
